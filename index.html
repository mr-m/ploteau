<html>
    <head>
        <title>Test mode</title>
        <style>html, body { margin: 0; }</style>
    </head>
    <body>
        <script src="//raw.github.com/mrdoob/three.js/master/build/three.min.js"></script>
        <script src="//raw.github.com/josdejong/mathjs/master/math.min.js"></script>
        <script src="//raw.github.com/andrewplummer/Sugar/master/release/sugar.min.js"></script>
        <script src="//raw.github.com/mrdoob/stats.js/master/build/stats.min.js"></script>
        <script>
            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.body.appendChild( stats.domElement );

            setInterval( function () {

                stats.begin();

                // your code goes here

                stats.end();

            }, 1000 / 60 );

            // Структура, описывающая сплайн на каждом сегменте сетки
            splines = [];

            function SplineTuple(a, b, c, d, x) {
                if (typeof a === 'undefined') a = 0;
                if (typeof b === 'undefined') b = 0;
                if (typeof c === 'undefined') c = 0;
                if (typeof d === 'undefined') d = 0;
                if (typeof x === 'undefined') x = 0;

                this.a = a;
                this.b = b;
                this.c = c;
                this.d = d;
                this.x = x;
            }

            // Построение сплайна
            // x - узлы сетки, должны быть упорядочены по возрастанию, кратные узлы запрещены
            // y - значения функции в узлах сетки
            // n - количество узлов сетки
            function BuildSpline(x, y, n)
            {
                // Инициализация массива сплайнов
                for (var i = 0; i < n; ++i) {
                    splines[i] = new SplineTuple();
                }
                for (var i = 0; i < n; ++i)
                {
                    splines[i].x = x[i];
                    splines[i].a = y[i];
                }
                splines[0].c = splines[n - 1].c = 0.0;

                // Решение СЛАУ относительно коэффициентов сплайнов c[i] методом прогонки для трехдиагональных матриц
                // Вычисление прогоночных коэффициентов - прямой ход метода прогонки
                var alpha = new Array(n - 1);
                var beta  = new Array(n - 1);
                alpha[0] = beta[0] = 0.0;
                for (var i = 1; i < n - 1; ++i)
                {
                    var hi  = x[i] - x[i - 1];
                    var hi1 = x[i + 1] - x[i];
                    var A = hi;
                    var C = 2.0 * (hi + hi1);
                    var B = hi1;
                    var F = 6.0 * ((y[i + 1] - y[i]) / hi1 - (y[i] - y[i - 1]) / hi);
                    var z = (A * alpha[i - 1] + C);
                    alpha[i] = -B / z;
                    beta[i] = (F - A * beta[i - 1]) / z;
                }

                // Нахождение решения - обратный ход метода прогонки
                for (var i = n - 2; i > 0; --i)
                {
                    splines[i].c = alpha[i] * splines[i + 1].c + beta[i];
                }

                // По известным коэффициентам c[i] находим значения b[i] и d[i]
                for (var i = n - 1; i > 0; --i)
                {
                    var hi = x[i] - x[i - 1];
                    splines[i].d = (splines[i].c - splines[i - 1].c) / hi;
                    splines[i].b = hi * (2.0 * splines[i].c + splines[i - 1].c) / 6.0 + (y[i] - y[i - 1]) / hi;
                }
            }

            // Вычисление значения интерполированной функции в произвольной точке
            function Interpolate(x)
            {
                if (splines == null)
                {
                    return double.NaN; // Если сплайны ещё не построены - возвращаем NaN
                }

                var n = splines.length;
                var s = new SplineTuple();

                if (x <= splines[0].x) // Если x меньше точки сетки x[0] - пользуемся первым эл-тов массива
                {
                    s = splines[1];
                }
                else if (x >= splines[n - 1].x) // Если x больше точки сетки x[n - 1] - пользуемся последним эл-том массива
                {
                    s = splines[n - 1];
                }
                else // Иначе x лежит между граничными точками сетки - производим бинарный поиск нужного эл-та массива
                {
                    var i = 0;
                    var j = n - 1;
                    while (i + 1 < j)
                    {
                        // Force to unsigned int32
                        var k = (i + (j - i) / 2) >>> 0;
                        if (x <= splines[k].x)
                        {
                            j = k;
                        }
                        else
                        {
                            i = k;
                        }
                    }
                    s = splines[j];
                }

                var dx = x - s.x;
                // Вычисляем значение сплайна в заданной точке по схеме Горнера (в принципе, "умный" компилятор применил бы схему Горнера сам, но ведь не все так умны, как кажутся)
                return s.a + (s.b + (s.c / 2.0 + s.d * dx / 6.0) * dx) * dx;
            }

            var scene    = new THREE.Scene();
            var camera   = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera.position.z = 15;

            var light = new THREE.SpotLight();
            light.position.set(10, 10, 10);
            scene.add(light);

            var axes = new THREE.AxisHelper(10);
            scene.add(axes);

            // create the particle variables
            var particles = new THREE.Geometry(),
                pMaterial =
                    new THREE.ParticleBasicMaterial({
                        color: 0xFFAAAA,
                        size: 0.1,
                        transparent: true
                    });


            XX = [-5,-4,-3,-2,-1, 0, 1, 2, 3, 4, 5];
            YY = [-5,-4,-3,-2,-1, 0, 1, 2, 3, 4, 5];
            ZZ = [];

            math.import({
                myfun: function (x, y) {
                    return math.re(math.pow(x*y, 1/3));
                    //return math.re(math.asin(math.complex(x, y)^3));// * math.im(math.asin(math.complex(x, y)^3));
                }
            });


            for (var i = 0; i < XX.length; i++) {
                ZZ[i] = [];
                for (var j = 0; j < YY.length; j++) {

                    ZZ[i][j] = math.myfun(XX[i], YY[j]);
                }
            };

            for (var i = 0; i < XX.length; i++) {
                BuildSpline(YY, ZZ[i], YY.length);
                var pos = YY[0];
                // now create the individual particles
                while (pos <= YY[YY.length - 1]) {
                    // create a particle with random
                    // position values, -250 -> 250
                    var pX = XX[i],
                        pY = pos,
                        pZ = Interpolate(pos),
                        particle = new THREE.Vector3(pX, pY, pZ);

                    // add it to the geometry
                    particles.vertices.push(particle);

                    pos += 0.1;
                }
            };

            for (var i = 0; i < YY.length; i++) {

                var ar = [];

                for (var j = 0; j < XX.length; j++) {
                    ar[j] = ZZ[j][i];
                };

                BuildSpline(XX, ar, XX.length);
                var pos = YY[0];
                // now create the individual particles
                while (pos <= YY[YY.length - 1]) {
                    // create a particle with random
                    // position values, -250 -> 250
                    var pX = pos,
                        pY = YY[i],
                        pZ = Interpolate(pos),
                        particle = new THREE.Vector3(pX, pY, pZ);

                    // add it to the geometry
                    particles.vertices.push(particle);

                    pos += 0.1;
                }
            };

            // create the particle system
            var particleSystem =
                new THREE.ParticleSystem(
                    particles,
                    pMaterial
                );

            particleSystem.sortParticles = true;

            // add it to the scene
            scene.add(particleSystem);


            var down = false;
            var sx = 0, sy = 0;
            window.onmousedown = function (ev) {
                down = true; sx = ev.clientX; sy = ev.clientY;
            };
            window.onmouseup = function () { down = false; };
            window.onmousemove = function (ev) {
                if (down) {
                    var dx = ev.clientX - sx;
                    var dy = ev.clientY - sy;

                    particleSystem.rotation.z += dx * 0.01;
                    particleSystem.rotation.x += dy * 0.01;

                    axes.rotation.z += dx * 0.01;
                    axes.rotation.x += dy * 0.01;

                    sx += dx;
                    sy += dy;
                }
            }

            function render() {
                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }
            render();
        </script>
    </body>
</html>